/*
This is a subset of the tests used by the simply-deferreds library. It is
included to test for parity. All rights to the below code belong to:

  Sudhir Jonathan <contact.me@sudhirjonathan.com>
  (http://www.sudhirjonathan.com)

*/

// Generated by CoffeeScript 1.3.1
(function() {
  var assert, assertHasPromiseApi, assertIsPromise, deferred, expectedMethods, _,
    __slice = [].slice;

  deferred = require('./defer');

  assert = require('assert');

  _ = require('underscore');

  expectedMethods = ['done', 'fail', 'always', 'state', 'then', 'pipe'];

  assertHasPromiseApi = function(promise) {
    var method, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = expectedMethods.length; _i < _len; _i++) {
      method = expectedMethods[_i];
      _results.push(assert(_.has(promise, method)));
    }
    return _results;
  };

  assertIsPromise = function(promise) {
    return assertHasPromiseApi(promise);
  };

  describe('deferred', function() {
    it('should create and return a deferred object', function() {
      var def;
      def = new deferred.Deferred();
      return assert.equal(def.state(), "pending");
    });
    it('should maintain a resolved state', function() {
      var def;
      def = new deferred.Deferred();
      assert.equal(def.state(), "pending");
      def.resolve();
      assert.equal(def.state(), "resolved");
      def.resolve();
      assert.equal(def.state(), "resolved");
      def.reject();
      return assert.equal(def.state(), "resolved");
    });
    it('should maintain a rejected state', function() {
      var def;
      def = new deferred.Deferred();
      assert.equal(def.state(), "pending");
      def.reject();
      assert.equal(def.state(), "rejected");
      def.reject();
      assert.equal(def.state(), "rejected");
      def.resolve();
      return assert.equal(def.state(), "rejected");
    });
    it('should call all the done callbacks', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.done(callback).done([callback, callback]);
      def.resolve();
      def.done(callback, callback);
      def.reject();
      def.done(callback, [callback, callback]);
      return def.fail(callback, callback);
    });
    it('should scope done callbacks when using resolveWith', function(done) {
      var callback, def, finish, finishHolder;
      callback = _.after(2, done);
      def = new deferred.Deferred();
      finishHolder = {
        finisher: callback
      };
      finish = function(arg1) {
        assert.equal(42, arg1);
        return this.finisher();
      };
      def.done(finish);
      def.always(function() {
        return callback();
      });
      def.resolveWith(finishHolder, 42);
      return assert.equal(def.state(), 'resolved');
    });
    it('should scope fail callbacks when using rejectWith', function(done) {
      var callback, def, finish, finishHolder;
      callback = _.after(2, done);
      def = new deferred.Deferred();
      finishHolder = {
        finisher: callback
      };
      finish = function(arg1) {
        assert.equal(42, arg1);
        return this.finisher();
      };
      def.fail(finish);
      def.always(function() {
        return callback();
      });
      def.rejectWith(finishHolder, 42);
      return assert.equal(def.state(), 'rejected');
    });
    it('should call all the fail callbacks', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.fail(callback).fail([callback, callback]);
      def.reject();
      def.fail(callback, callback);
      def.resolve();
      def.fail(callback, [callback, callback]);
      return def.done(callback);
    });
    it('should call all the always callbacks on resolution', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.always(callback).always([callback, callback]);
      def.resolve();
      def.always(callback, callback);
      def.always(callback, [callback, callback]);
      return def.fail(callback);
    });
    it('should call the always callbacks on rejection', function(done) {
      var def;
      def = new deferred.Deferred();
      def.always(done);
      def.reject();
      return def.done(done);
    });
    it('should call callbacks with arguments', function(done) {
      var callback, finish;
      finish = _.after(8, done);
      callback = function(arg1, arg2) {
        if (arg1 === 42 && arg2 === 24) {
          return finish();
        }
      };
      new deferred.Deferred().always(callback).resolve(42, 24).always(callback);
      new deferred.Deferred().always(callback).reject(42, 24).always(callback);
      new deferred.Deferred().done(callback).resolve(42, 24).done(callback);
      return new deferred.Deferred().fail(callback).reject(42, 24).fail(callback);
    });
    it('should provide a when method', function(done) {
      var all, callback, def1, def2, def3;
      callback = _.after(4, function() {
        return done();
      });
      def1 = new deferred.Deferred().done(callback);
      def2 = new deferred.Deferred().done(callback);
      def3 = new deferred.Deferred().done(callback);
      all = deferred.when(def1, def2, def3).done(callback);
      def1.resolve();
      def2.resolve();
      return def3.resolve();
    });
    describe('then', function() {
      it('should then on resolution', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 10) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.then(function(value) {
          return value * 2;
        });
        def.resolve(5);
        return filtered.done(finisher);
      });
      it('should then on rejection', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 6) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.then(null, function(value) {
          return value * 3;
        });
        def.reject(2);
        return filtered.fail(finisher);
      });
      it('should pass through for null filters for done', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 5) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.then(null, null);
        def.resolve(5);
        return filtered.done(finisher);
      });
      return it('should pass through for null filters for fail', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 5) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.then(null, null);
        def.reject(5);
        return filtered.fail(finisher);
      });
    });
    describe('promises', function() {
      it('should provide a promise that has a restricted API', function(done) {
        var callback, def, promise;
        def = new deferred.Deferred();
        promise = def.promise();
        assertIsPromise(promise);
        callback = _.after(5, done);
        promise.always(callback).always(callback).fail(callback).done(callback).fail(callback);
        assertIsPromise(promise.done(callback));
        assertIsPromise(promise.fail(callback));
        assertIsPromise(promise.always(callback));
        assert("pending", promise.state());
        def.resolve();
        return assert("resolved", promise.state());
      });
      it('should create a promise out of a given object', function() {
        var candidate, def, promise;
        candidate = {
          id: 42
        };
        def = new deferred.Deferred();
        promise = def.promise(candidate);
        assert.equal(candidate, promise);
        return assertHasPromiseApi(candidate);
      });
      return describe('when', function() {
        it('should return a promise', function() {
          return assertIsPromise(deferred.when(new deferred.Deferred()));
        });
        it('should resolve when all deps have succeeded', function() {
          var after_all, d1, d2;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          after_all = deferred.when(d1, d2);
          d1.resolve();
          assert.equal(after_all.state(), 'pending');
          d2.resolve();
          return assert.equal(after_all.state(), 'resolved');
        });
        it('should reject when there are some failures', function() {
          var after_all, d1, d2;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          after_all = deferred.when(d1, d2);
          d1.resolve();
          assert.equal(after_all.state(), 'pending');
          d2.reject();
          return assert.equal(after_all.state(), 'rejected');
        });
        it('should pass on reject arguments', function(done) {
          var after_all, d1, d2;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          after_all = deferred.when(d1, d2);
          after_all.fail(function(arg1) {
            if (arg1 === 42) {
              return done();
            }
          });
          d1.resolve();
          return d2.reject(42);
        });
        it('should pass on resolve arguments as is when used with a single deferred', function(done) {
          var after_all, d1;
          d1 = new deferred.Deferred();
          after_all = deferred.when(d1);
          after_all.done(function(arg1) {
            if (arg1 === 42) {
              return done();
            }
          });
          return d1.resolve(42);
        });
        return it('should pass on arrays of arguments when used with multiple deferreds', function(done) {
          var after_all, d1, d2, d3;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          d3 = new deferred.Deferred();
          after_all = deferred.when(d1, d2, d3);
          after_all.done(function(arg1, arg2, arg3) {
            assert.deepEqual(arg1, [42]);
            assert.deepEqual(arg2, []);
            assert.deepEqual(arg3, ['abc', 123]);
            return done();
          });
          d2.resolve();
          d3.resolve('abc', 123);
          return d1.resolve(42);
        });
      });
    });
  });

}).call(this);